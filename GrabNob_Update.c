#pragma config(Sensor, port3,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port10, LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor4,          FrontClaw,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          RightDrive,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor6,          Convayor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         LeftDrive,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor12,         BackLock,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//The circomfrince of the wheel is 7.85
// 1 rotation is 7.85 inches
// 1 rotation is 360 degrees

void forwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, distance, speed);
	moveMotorTarget(RightDrive, distance, speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}
void backwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, -distance, -speed);
	moveMotorTarget(RightDrive, -distance, -speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}

void turnRightDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = speed;
	motor[RightDrive] = -speed;
	waitUntil(getGyroDegreesFloat(Gyro) <= -degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);
	if(getGyroDegreesFloat(Gyro) < -degToMove) {
		motor[LeftDrive] = -10;
		motor[RightDrive] = 10;
		waitUntil(getGyroDegreesFloat(Gyro) >= -degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}
}

void turnLeftDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = -speed;
	motor[RightDrive] = speed;
	waitUntil(getGyroDegreesFloat(Gyro) >= degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);

	if(getGyroDegreesFloat(Gyro) > degToMove) {
		motor[LeftDrive] = 10;
		motor[RightDrive] = -10;
		waitUntil(getGyroDegreesFloat(Gyro) <= degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}

}

void waitForTouch(){
	setTouchLEDColor(LED, colorRed);
	waitUntil(getTouchLEDValue(LED) == 1);
	setTouchLEDColor(LED, colorGreen);
}

void firstGreen(){
	motor[Convayor] = 100;
	moveMotorTarget(FrontClaw, -1000, -100);
	forwardMove(12,50);

	turnRightDist(90,50);
	forwardMove(290,30);
	turnLeftDist(130,30);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnRightDist(55,30);
	forwardMove(230,50);
	//turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(210,50);
}

void secondGreen(){
	moveMotorTarget(FrontClaw,-1000,-1000);
	turnRightDist(60,30);
	forwardMove(345,30);
	turnRightDist(98,30);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 800, 50);
	forwardMove(200,50);
	//turnRightDist(66,30);
	//New turning code

	turnRightDist(110,30);
	forwardMove(350,30);
	turnLeftDist(85,20);
	forwardMove(50,30);




	moveMotorTarget(FrontClaw, 900, 50);
	//forwardMove(250,50);
	moveMotorTarget(FrontClaw, -200, -50);
	forwardMove(30,50);
	waitUntilMotorMoveComplete(RightDrive);
	backwardMove(90,50);
	stopAllMotors();
}

void getThirdGreen() {
	motor[Convayor] = 100;
	moveMotorTarget(FrontClaw, -1000, -100);
	forwardMove(12,50);

	turnLeftDist(90,50);
	forwardMove(290,30);
	turnRightDist(135,50);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnLeftDist(46,30);
	forwardMove(235,50);
	//turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(200,50);
}

task main()
{
	waitForTouch();
	firstGreen();
	secondGreen();
	waitForTouch();
	getThirdGreen();
}
