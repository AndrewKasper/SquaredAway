#pragma config(Sensor, port3,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port10, LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor4,          FrontClaw,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          RightDrive,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor6,          Convayor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         LeftDrive,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor12,         BackLock,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//The circomfrince of the wheel is 7.85
// 1 rotation is 7.85 inches
// 1 rotation is 360 degrees

void forwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, distance, speed);
	moveMotorTarget(RightDrive, distance, speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}
void backwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, -distance, -speed);
	moveMotorTarget(RightDrive, -distance, -speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}

void turnRightDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = speed;
	motor[RightDrive] = -speed;
	waitUntil(getGyroDegreesFloat(Gyro) <= -degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);
	if(getGyroDegreesFloat(Gyro) < -degToMove) {
		motor[LeftDrive] = -10;
		motor[RightDrive] = 10;
		waitUntil(getGyroDegreesFloat(Gyro) >= -degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}
}

void turnLeftDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = -speed;
	motor[RightDrive] = speed;
	waitUntil(getGyroDegreesFloat(Gyro) >= degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);

	if(getGyroDegreesFloat(Gyro) > degToMove) {
		motor[LeftDrive] = 10;
		motor[RightDrive] = -10;
		waitUntil(getGyroDegreesFloat(Gyro) <= degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}

}

void waitForTouch(){
	setTouchLEDColor(LED, colorRed);
	waitUntil(getTouchLEDValue(LED) == 1);
	setTouchLEDColor(LED, colorGreen);
}

void firstGreen(){
	motor[Convayor] = 100;
	moveMotorTarget(FrontClaw, -1000, -100);
	forwardMove(12,50);

	turnRightDist(90,50);
	forwardMove(290,30);
	turnLeftDist(135,50);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnRightDist(47,30);
	forwardMove(240,50);
	//turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(200,50);
}

void secondGreen(){
	moveMotorTarget(FrontClaw,-1000,-1000);
	turnRightDist(52,30);
	forwardMove(335,30);
	turnRightDist(95,30);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnRightDist(58,30);
	forwardMove(250,50);
	moveMotorTarget(FrontClaw, -200, -50);
}

void getThirdGreen() {
	moveMotorTarget(FrontClaw, -1000, -100);
	forwardMove(12,50);

	turnLeftDist(90,50);
	forwardMove(290,30);
	turnRightDist(135,50);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnLeftDist(47,30);
	forwardMove(235,50);
	turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(200,50);
}

task main()
{
	waitForTouch();
	firstGreen();
	secondGreen();
	waitForTouch();
	getThirdGreen();
}
