#pragma config(Sensor, port3,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port10, LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor4,          FrontClaw,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          RightDrive,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor6,          Convayor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         LeftDrive,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor12,         BackLock,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//The circomfrince of the wheel is 7.85
// 1 rotation is 7.85 inches
// 1 rotation is 360 degrees

void forwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, distance, speed);
	moveMotorTarget(RightDrive, distance, speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}
void backwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, -distance, -speed);
	moveMotorTarget(RightDrive, -distance, -speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.
	waitUntilMotorStop(LeftDrive);
	waitUntilMotorStop(RightDrive);
}

void turnRightDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = speed;
	motor[RightDrive] = -speed;
	waitUntil(getGyroDegreesFloat(Gyro) <= -degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);
	if(getGyroDegreesFloat(Gyro) < -degToMove) {
		motor[LeftDrive] = -10;
		motor[RightDrive] = 10;
		waitUntil(getGyroDegreesFloat(Gyro) >= -degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}
}

void turnLeftDist(float deg, int speed){
	int degToMove = (deg - 1);
	resetGyro(Gyro);
	motor[LeftDrive] = -speed;
	motor[RightDrive] = speed;
	waitUntil(getGyroDegreesFloat(Gyro) >= degToMove);
	stopMotor(LeftDrive);
	stopMotor(RightDrive);

	if(getGyroDegreesFloat(Gyro) > degToMove) {
		motor[LeftDrive] = 10;
		motor[RightDrive] = -10;
		waitUntil(getGyroDegreesFloat(Gyro) <= degToMove);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}

}

void waitForTouch(){
	setTouchLEDColor(LED, colorRed);
	waitUntil(getTouchLEDValue(LED) == 1);
	setTouchLEDColor(LED, colorGreen);
}

void firstGreen(){
	motor[Convayor] = 100;
	backwardMove(65, 10);
	sleep(500);
	forwardMove(60, 10);
	sleep(500);
	//Get Red
	forwardMove(25,50);
	turnRightDist(103,50);
	moveMotorTarget(FrontClaw, -1000, -100);
	backwardMove(100,50);
	moveMotorTarget(BackLock, -400,50);
	backwardMove(70,10);
	//sleep(750);
	//waitUntilMotorStop(BackLock);
	backwardMove(200,50);
	//Get Green Middle
	turnLeftDist(50,50);
	//sleep(3750);
	forwardMove(135,30);
	//turnLeftDist(20,30);
	forwardMove(120,50);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(150,50);
	turnRightDist(90,30);
	forwardMove(450,50);
	moveMotorTarget(FrontClaw,-200,-30);
	waitUntilMotorMoveComplete(FrontClaw);
	forwardMove(20,50);
	moveMotorTarget(FrontClaw,-200,-30);
	backwardMove(90,50);

}

void secondGreen(){
	turnLeftDist(80,30);
	moveMotorTarget(FrontClaw,-1000,-1000);
	//waitUntilMotorMoveComplete(FrontClaw);
	sleep(600);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 800, 50);
	forwardMove(200,50);
	turnLeftDist(103,30);
	forwardMove(490,50);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(750,50);
	moveMotorTarget(BackLock, 300, 100);
	backwardMove(550, 100);
	forwardMove(100, 100);
	stopMotor(Convayor);

}

void getThirdGreen() {
	motor[Convayor] = 100;
	moveMotorTarget(FrontClaw, -1000, -100);
	forwardMove(12,50);

	turnLeftDist(90,50);
	forwardMove(290,30);
	turnRightDist(135,50);
	forwardMove(175,30);
	moveMotorTarget(FrontClaw, 900, 50);
	forwardMove(200,50);
	turnLeftDist(47,30);
	forwardMove(235,50);
	//turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-400,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(200,50);
}

task main()
{
	waitForTouch();
	firstGreen();
	secondGreen();
	waitForTouch();
	getThirdGreen();
}
