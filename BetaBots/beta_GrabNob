#pragma config(Sensor, port3,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port10, LED,            sensorVexIQ_LED)
#pragma config(Motor,  motor4,          FrontClaw,     tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor5,          RightDrive,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motor6,          Convayor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor11,         LeftDrive,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motor12,         BackLock,      tmotorVexIQ, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//The circomfrince of the wheel is 7.85
// 1 rotation is 7.85 inches
// 1 rotation is 360 degrees

void forwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, distance, speed);
	moveMotorTarget(RightDrive, distance, speed);
	//Holds program flow until the motor on port 1 comes to a complete stop.

  //Keep looping until the motor stops moving
	sleep(100);
	while(getMotorZeroVelocity(LeftDrive) == 0  && getMotorZeroVelocity(RightDrive) == 0)
	{
		if(getMotorZeroVelocity(LeftDrive) == 1) {stopMotor(RightDrive);}
		if(getMotorZeroVelocity(RightDrive) == 1) {stopMotor(LeftDrive);}
	}
	stopMotor(RightDrive);
	stopMotor(LeftDrive);
}

void backwardMove(int distance, int speed){
	moveMotorTarget(LeftDrive, -distance, -speed);
	moveMotorTarget(RightDrive, -distance, -speed);

	  //Keep looping until the motor stops moving
	sleep(100);
	while(getMotorZeroVelocity(LeftDrive) == 0  && getMotorZeroVelocity(RightDrive) == 0)
	{
		if(getMotorZeroVelocity(LeftDrive) == 1) {stopMotor(RightDrive);}
		if(getMotorZeroVelocity(RightDrive) == 1) {stopMotor(LeftDrive);}
	}
	stopMotor(RightDrive);
	stopMotor(LeftDrive);


	}


void turnRightDist(float deg, int speed){
//	int degToMove = (deg - 1);
	resetGyro(Gyro);
	int gyroValue = getGyroDegreesFloat(Gyro);
	int gyroValueNew = 0;
	if(deg > 0 && deg <=45 ){ gyroValueNew= (gyroValue + deg) * 0.745;}
	if(deg > 45 && deg <=90 ){ gyroValueNew= (gyroValue + deg) * 0.79;}
	if(deg > 90 && deg <=135 ){ gyroValueNew= (gyroValue + deg) * 0.835;}
	if(deg > 135 && deg <=180 ){ gyroValueNew= (gyroValue + deg) * 0.88;}
	if(deg > 180){ gyroValueNew= (gyroValue + deg) * 0.88;}

	//gyroValueNew= (gyroValue + deg) * 0.88;

	motor[LeftDrive] = speed;
	motor[RightDrive] = -speed;
	waitUntil(abs(getGyroDegreesFloat(Gyro)) >= gyroValueNew);
	
	  //Keep looping until the motor stops moving

	stopMotor(LeftDrive);
	stopMotor(RightDrive);
	resetGyro(Gyro);

/*	gyroValue = abs(getGyroDegreesFloat(Gyro));
	int gyroValueFix = abs(gyroValueNew - gyroValue);
	resetGyro(Gyro);
	if(getGyroDegreesFloat(Gyro) < gyroValueFix) {
		motor[LeftDrive] = -10;
		motor[RightDrive] = 10;
		waitUntil(abs(getGyroDegreesFloat(Gyro)) > gyroValueFix);
		stopMotor(LeftDrive);
		stopMotor(RightDrive);
	}*/
}


void turnLeftDist(float deg, int speed){

	resetGyro(Gyro);
	int gyroValue = getGyroDegreesFloat(Gyro);
	int gyroValueNew = 0;
	if(deg > 0 && deg <=45 ){ gyroValueNew= (gyroValue + deg) * 0.745;}
	if(deg > 45 && deg <=90 ){ gyroValueNew= (gyroValue + deg) * 0.79;}
	if(deg > 90 && deg <=135 ){ gyroValueNew= (gyroValue + deg) * 0.835;}
	if(deg > 135 && deg <=180 ){ gyroValueNew= (gyroValue + deg) * 0.88;}
	if(deg > 180){ gyroValueNew= (gyroValue + deg) * 0.88;}

	//gyroValueNew= (gyroValue + deg) * 0.88;

	motor[LeftDrive] = -speed;
	motor[RightDrive] = speed;
	waitUntil(abs(getGyroDegreesFloat(Gyro)) >= gyroValueNew);
	  //Keep looping until the motor stops moving
	stopMotor(LeftDrive);
	stopMotor(RightDrive);
	resetGyro(Gyro);

}

void waitForTouch(){
	setTouchLEDColor(LED, colorRed);
	waitUntil(getTouchLEDValue(LED) == 1);
	setTouchLEDColor(LED, colorGreen);
}

void firstGreen() {
	motor[Convayor] = 100;
	forwardMove(28,100);   //originally 12
	turnRightDist(85,50);
	moveMotorTarget(FrontClaw, -485, -100);
	setMotorBrakeMode(FrontClaw, motorCoast);
	forwardMove(290,30);  // orginally 315
	turnLeftDist(130,50);  //orginally 135
	forwardMove(220,30);   //originally  220
	sleep(200);
	moveMotorTarget(FrontClaw, 475, 50);
	forwardMove(210,20);   //originally 255
	turnRightDist(30,30);
	forwardMove(180,30);   //originally 210
	sleep(200);
	//turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-300,-50);
	forwardMove(80,30);   //originally 210
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(140,50);
	moveMotorTarget(FrontClaw,300,50);
	stopMotor(Convayor);

}

void secondGreen() {
	motor[Convayor] = 100;
	forwardMove(28,100);   //originally 12
	turnRightDist(85,50);
	moveMotorTarget(FrontClaw, -485, -100);
	setMotorBrakeMode(FrontClaw, motorCoast);
	forwardMove(290,30);  // orginally 315
	turnLeftDist(45,50);  //orginally 135
	forwardMove(240,20);   //originally  220
	sleep(200);
	moveMotorTarget(FrontClaw, 475, 50);
	forwardMove(100,20);   //originally 255
	backwardMove(250,30);
  setMotorBrakeMode(FrontClaw, motorHold);
  moveMotorTarget(FrontClaw, 90, 100);
	turnRightDist(93,50);  //orginally 135
//	forwardMove(230,20);   //originally 255
	forwardMove(80,20);   //Work on this distance  --- start
  sleep(500);
//	turnLeftDist(20,50);
  moveMotorTarget(FrontClaw,-120,-30);
  sleep(1000);
	forwardMove(60,50);
  moveMotorTarget(FrontClaw,25,30);
	backwardMove(200,50);  //working on this  -- currently 60
	
	stopMotor(Convayor);
}

void thirdGreen() {
	motor[Convayor] = 100;
	forwardMove(28,100);   //originally 12
	turnLeftDist(85,50);
	moveMotorTarget(FrontClaw, -485, -100);
	setMotorBrakeMode(FrontClaw, motorCoast);
	forwardMove(290,20);  // orginally 315
	turnRightDist(130,50);  //orginally 135
	forwardMove(220,20);   //originally  220
	sleep(200);
	moveMotorTarget(FrontClaw, 475, 50);
	forwardMove(200,20);   //originally 255
	turnLeftDist(30,30);
	forwardMove(180,30);   //originally 210
	sleep(200);
	//turnLeftDist(10,10);
	moveMotorTarget(FrontClaw,-300,-50);
	forwardMove(60,30);   //originally 210
	waitUntilMotorMoveComplete(FrontClaw);
	backwardMove(180,50);

	//Get Blue
	moveMotorTarget(FrontClaw,-150,-50);
	waitUntilMotorMoveComplete(FrontClaw);
	turnRightDist(88,50);
	forwardMove(320,50);     //originally 355
	turnLeftDist(93,50);
	forwardMove(140,30);     //orginally
	moveMotorTarget(FrontClaw, 440, 100);
	forwardMove(30,30);     //orginally
	waitUntilMotorMoveComplete(FrontClaw);
	//Place Blue
	turnRightDist(45,50);
	backwardMove(400,50);
	turnLeftDist(135,50);
	forwardMove(500,100);
	forwardMove(300,100);
	turnLeftDist(25,70);
	moveMotorTarget(FrontClaw,-300,-100);
	sleep(500);
	moveMotorTarget(FrontClaw,-140,-100);
//	waitUntilMotorMoveComplete(FrontClaw);
	forwardMove(700,50);
	backwardMove(200,50);  //working on this  -- currently 90
	
	stopMotor(Convayor);

}


task main()
{
//	waitForTouch();
//	firstGreen();
//	waitForTouch();
//	secondGreen();
	waitForTouch();
	thirdGreen();
}
